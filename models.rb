# From the command line:
$ bin/rails generate migration CreateJobs

# db/migrate/20150223155659_create_jobs.rb
class CreateJobs < ActiveRecord::Migration
  def self.up
    create_table :jobs do |t|
      t.text :name, null: false
      t.boolean :published, null: false
      t.timestamps null: false
    end
  end

  def self.down
    drop_table :jobs
  end
end

# app/models/job.rb
class Job < ActiveRecord::Base
  validates_with ObseneValidator
  scope :published { where(published: true) }
end

# db/schema.rb (Autogenerated when migration is run)
create_table "jobs", force: :cascade do |t|
  t.text     "name",         null: false
  t.boolean  "published",    null: false
  t.datetime "created_at",   null: false
  t.datetime "updated_at",   null: false
end

# From the console:
>>> Job.find(2)
>>> Job.all

### Notes:
# * Migrations are where you start with instead of being generated from your
#   model
# * timestamps great (not in django by default, but not hard to add)
# * models file doesn't contain infomation about what is in the model
#   so there is not centralized place for this information
# * ActiveRecord::Base has 100s of methods that connect to the API that pollute
#   your interface in Django those are moved to the Manager
# * Django ORMs naming choice and syntax is closer to SQL
# * Rails annotate models: gem
# * Avdi grim (not starting with a migrations)
