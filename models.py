## job/models.py
from django.db import models

from .managers import JobsManager


class Job(models.Model):
    objects = JobsManager()

    name = models.CharField(blank=False, max_length=100, null=False)
    published = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)


# Ran from the command line
$ python manage.py makemigrations jobs

# job/managers.py

from django.db.models import Manager


class JobManager(Manager):
    #TODO: write to match publiushed
    def get_queryset(self):
        return super(JobManager, self).get_queryset().filter(published=True)


# From the console
>>> Job.objects.get(id=2)
>>> Job.objects.all()

### Notes:
# * From the docs: "A Manager is the interface through which database
#   query operations are provided to Django models.
#   At least one Manager exists for every model in a Django application."
# * Migration are autogenerated by examining the changed in your models
# * Migrations are order by number
# * Migrations can depend_on migrations from other apps
# * Migrations aren't timestamped
# * Migrations are seperated by "app"
# * The concept of an "app" is very different than Rail's concept
# * super is super explicate
# * imports are super explicate
